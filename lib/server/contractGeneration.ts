import { contractsService } from "@/lib/services/contractsService";
import { prisma } from "@/lib/db";
import { callWithContentRetry } from "@/lib/mcp/llmUtils";
import { callProviderLLM } from "@/lib/mcp/providerClient";
import { buildContractContext } from "@/lib/copilot/context/contracts";
import {
  buildContractDraftPrompt,
  buildContractReviewPrompt,
} from "@/lib/copilot/prompts/contracts";
import { CopilotLLMMessage } from "@/lib/copilot/types";
import { saveReviewStateToDb } from "./contractReview";

export type ContractGenerationOptions = {
  runAutoReview?: boolean;
};

type GenerateArgs = {
  agreementId: string;
  instructions?: string;
  excludedPolicyIds?: string[];
  options?: ContractGenerationOptions;
};

export async function generateContractDraftForAgreement({
  agreementId,
  instructions,
  excludedPolicyIds,
  options,
}: GenerateArgs): Promise<{ success: boolean; error?: string }> {
  try {
    const context = await buildContractContext(
      agreementId,
      undefined,
      excludedPolicyIds,
    );

    if (!context.agreement) {
      return { success: false, error: "Agreement not found" };
    }

    const { systemPrompt, messages } = buildContractDraftPrompt({
      agreementType: context.agreement.type,
      counterparty: context.agreement.counterparty,
      digestText: context.digestText,
      instructions,
    });

    const { content } = await callWithContentRetry({
      label: "contract-draft",
      initialTokens: 5000,
      maxTokens: 12000,
      callFactory: (maxTokens) =>
        callProviderLLM({
          systemPrompt,
          messages: messages as CopilotLLMMessage[],
          maxTokens,
          temperature: 0.3,
        }),
    });

    if (!content || !content.trim()) {
      return { success: false, error: "Copilot returned empty content." };
    }

    const latestVersion = await contractsService.getLatestVersion(agreementId);
    if (!latestVersion) {
      return { success: false, error: "No version found to update" };
    }

    const trimmedContent = content.trim();
    const isInitialEmpty =
      latestVersion.versionNumber === 1 && !latestVersion.content;

    if (isInitialEmpty) {
      await prisma.agreementVersion.update({
        where: { id: latestVersion.id },
        data: {
          content: trimmedContent,
          changeNote: "Initial draft generated by Copilot",
        },
      });
    } else {
      await contractsService.createVersion({
        agreementId,
        content: trimmedContent,
        changeNote: instructions
          ? `Regenerated with instructions: ${instructions}`
          : "Regenerated by Copilot",
      });
    }

    if (options?.runAutoReview) {
      await runPolicyReviewForDraft({
        agreementId,
        draftContent: trimmedContent,
        context: {
          agreementType: context.agreement.type,
          digestText: context.digestText,
        },
      });
    }

    return { success: true };
  } catch (error) {
    console.error("Error generating contract draft:", error);
    const message =
      error instanceof Error ? error.message : "Generation exception";
    return { success: false, error: message };
  }
}

export async function runPolicyReviewForDraft({
  agreementId,
  draftContent,
  context,
}: {
  agreementId: string;
  draftContent: string;
  context?: {
    agreementType: string;
    digestText: string;
  };
}) {
  try {
    let reviewContext = context;
    if (!reviewContext) {
      const fallbackContext = await buildContractContext(agreementId);
      if (!fallbackContext.agreement) {
        throw new Error("Agreement not found");
      }
      reviewContext = {
        agreementType: fallbackContext.agreement.type,
        digestText: fallbackContext.digestText,
      };
    }

    const { systemPrompt, messages } = buildContractReviewPrompt({
      agreementType: reviewContext.agreementType,
      digestText: reviewContext.digestText,
      incomingDraft: draftContent,
    });

    const { content } = await callWithContentRetry({
      label: "contract-auto-review",
      initialTokens: 6000,
      maxTokens: 12000,
      callFactory: (maxTokens) =>
        callProviderLLM({
          systemPrompt,
          messages: messages as CopilotLLMMessage[],
          maxTokens,
          temperature: 0.2,
          responseFormat: "json_object",
        }),
    });

    if (!content) {
      console.warn("[generateContract] Auto review returned empty content.");
      return;
    }

    let parsed: any = null;
    try {
      parsed = JSON.parse(content);
    } catch (parseError) {
      console.error("Failed to parse auto review response", parseError);
      return;
    }

    if (!parsed?.proposals || !Array.isArray(parsed.proposals)) {
      return;
    }

    await saveReviewStateToDb(agreementId, parsed.proposals);
    await contractsService.updateAgreementStatus({
      id: agreementId,
      status: "REVIEW",
    });
  } catch (error) {
    console.error("[generateContract] Failed to run auto review", error);
  }
}

